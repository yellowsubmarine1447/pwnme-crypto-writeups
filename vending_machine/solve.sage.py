

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_443 = Integer(443); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_256 = Integer(256); _sage_const_7 = Integer(7); _sage_const_0xf1fd178c0b3ad58f10126de8ce42435b3961adbcabc8ca6de8fcf353d86e9c03 = Integer(0xf1fd178c0b3ad58f10126de8ce42435b3961adbcabc8ca6de8fcf353d86e9c03); _sage_const_0xf1fd178c0b3ad58f10126de8ce42435b3961adbcabc8ca6de8fcf353d86e9c00 = Integer(0xf1fd178c0b3ad58f10126de8ce42435b3961adbcabc8ca6de8fcf353d86e9c00); _sage_const_0xee353fca5428a9300d4aba754a44c00fdfec0c9ae4b1a1803075ed967b7bb73f = Integer(0xee353fca5428a9300d4aba754a44c00fdfec0c9ae4b1a1803075ed967b7bb73f); _sage_const_0xb6b3d4c356c139eb31183d4749d423958c27d2dcaf98b70164c97a2dd98f5cff = Integer(0xb6b3d4c356c139eb31183d4749d423958c27d2dcaf98b70164c97a2dd98f5cff); _sage_const_0x6142e0f7c8b204911f9271f0f3ecef8c2701c307e8e4c9e183115a1554062cfb = Integer(0x6142e0f7c8b204911f9271f0f3ecef8c2701c307e8e4c9e183115a1554062cfb); _sage_const_0xf1fd178c0b3ad58f10126de8ce42435b53dc67e140d2bf941ffdd459c6d655e1 = Integer(0xf1fd178c0b3ad58f10126de8ce42435b53dc67e140d2bf941ffdd459c6d655e1); _sage_const_1 = Integer(1); _sage_const_5 = Integer(5); _sage_const_70 = Integer(70); _sage_const_10 = Integer(10); _sage_const_32 = Integer(32); _sage_const_16 = Integer(16)
import os
os.environ['PWNLIB_NOTERM'] = "1" # pwntools sage is cooked??
os.environ["TERM"] = "xterm-256color"

from pwn import *
from tinyec.ec import SubGroup, Curve
from json import loads, dumps
from Crypto.Cipher import AES
from hashlib import sha3_256

host = "vendingmachine-ddf505bff2f08a36.deploy.phreaks.fr"
port = _sage_const_443 
p = remote(host, port, ssl=True, sni="vendingmachine-ddf505bff2f08a36.deploy.phreaks.fr")
owner_proofs = []
used_credit = _sage_const_0 
callnum = _sage_const_0 

B = _sage_const_2 **(_sage_const_256  - _sage_const_7 )



class SignatureManager:
    def __init__(self):
        # FRP256v1 Parameters
        self.p = _sage_const_0xf1fd178c0b3ad58f10126de8ce42435b3961adbcabc8ca6de8fcf353d86e9c03 
        self.a = _sage_const_0xf1fd178c0b3ad58f10126de8ce42435b3961adbcabc8ca6de8fcf353d86e9c00 
        self.b = _sage_const_0xee353fca5428a9300d4aba754a44c00fdfec0c9ae4b1a1803075ed967b7bb73f 
        self.Gx = _sage_const_0xb6b3d4c356c139eb31183d4749d423958c27d2dcaf98b70164c97a2dd98f5cff 
        self.Gy = _sage_const_0x6142e0f7c8b204911f9271f0f3ecef8c2701c307e8e4c9e183115a1554062cfb 
        self.n = _sage_const_0xf1fd178c0b3ad58f10126de8ce42435b53dc67e140d2bf941ffdd459c6d655e1 
        self.h = _sage_const_1 

        subgroup = SubGroup(self.p, (self.Gx, self.Gy), self.n, self.h)
        self.curve = Curve(self.a, self.b, subgroup, name="CustomCurve")

        self.P = self.curve.g

sm = SignatureManager()

class Sig:
    def __init__(self, t):
        self.m = int.from_bytes(sha3_256(bytes.fromhex(t[_sage_const_0 ])).digest())
        print(t[_sage_const_0 ], self.m, "yeah it's this")
        self.r = t[_sage_const_1 ]
        self.s = (-t[_sage_const_2 ]) % sm.n

def get_signatures():
    p.recvuntil(b"in JSON format: ")
    p.sendline(b'{"action": "get_signatures", "alea_1": -1, "alea_2": -2}')
    return eval(p.recvline()) # :trollface:

def buy_credit():
    global callnum
    p.recvuntil(b"in JSON format: ")
    payload = {
        "action": "buy_credit",
        "owner_proofs": owner_proofs[:callnum]
    }
    p.sendline(dumps(payload).encode())
    callnum += _sage_const_5 
    return p.recvline()

def get_encrypted_flag():
    p.recvuntil(b"in JSON format: ")
    p.sendline(b'{"action": "get_encrypted_flag"}')
    
    x = p.recvline().decode()
    return eval(x) # :trollface:

SIGS = _sage_const_70 

flag_info = get_encrypted_flag()
print(buy_credit())
for _ in range(SIGS // _sage_const_10 ):
    used_credit += _sage_const_1 
    for i, sig in enumerate(get_signatures()["signatures"]):
        m = sha3_256(b"this is my lovely loved distributed item " + str(i+_sage_const_10 *used_credit).encode()).digest().hex()
        owner_proofs.append((m, int(sig[_sage_const_0 ]), int((-sig[_sage_const_1 ]) % sm.n))) # sage loves Integers, but json dumping doesn't

    print(buy_credit())
    print(buy_credit())

sigs = list(map(Sig, owner_proofs))

m = Matrix(QQ, nrows=SIGS+_sage_const_1 , ncols=SIGS+_sage_const_1 ) # we operate on differences from signatures[0]
for i in range(SIGS-_sage_const_1 ):
    m[i,i] = sm.n
    m[SIGS-_sage_const_1 ,i] = (sigs[i+_sage_const_1 ].r * pow(sigs[i+_sage_const_1 ].s, -_sage_const_1 , sm.n) - sigs[_sage_const_0 ].r * pow(sigs[_sage_const_0 ].s, -_sage_const_1 , sm.n)) % sm.n
    m[SIGS,i] = (sigs[i+_sage_const_1 ].m * pow(sigs[i+_sage_const_1 ].s, -_sage_const_1 , sm.n) - sigs[_sage_const_0 ].m * pow(sigs[_sage_const_0 ].s, -_sage_const_1 , sm.n)) % sm.n

m[SIGS-_sage_const_1 ,SIGS-_sage_const_1 ] = B / sm.n
m[SIGS,SIGS] = B

m = m.LLL()

for row in m:
    if row[-_sage_const_1 ] == B:
        d = ((sigs[_sage_const_0 ].s * sigs[_sage_const_1 ].m) - (sigs[_sage_const_1 ].s * sigs[_sage_const_0 ].m) - (sigs[_sage_const_1 ].s * sigs[_sage_const_0 ].s * row[_sage_const_0 ])) % sm.n
        d = (d * pow(sigs[_sage_const_0 ].r * sigs[_sage_const_1 ].s - (sigs[_sage_const_1 ].r * sigs[_sage_const_0 ].s), -_sage_const_1 , sm.n)) % sm.n
        print(row)
        break
else:
    print("nup :(")
    quit()


key = sha3_256(int(d).to_bytes(_sage_const_32 , "big")).digest()[:_sage_const_16 ]
cipher = AES.new(key, IV=bytes.fromhex(flag_info["iv"]), mode=AES.MODE_CBC)
print(cipher.decrypt(bytes.fromhex(flag_info["encrypted_flag"])))

print(d_actual)
key = sha3_256(int(d_actual).to_bytes(_sage_const_32 , "big")).digest()[:_sage_const_16 ]
cipher = AES.new(key, IV=bytes.fromhex(flag_info["iv"]), mode=AES.MODE_CBC)
print(cipher.decrypt(bytes.fromhex(flag_info["encrypted_flag"])))

p.interactive()

